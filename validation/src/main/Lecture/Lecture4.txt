검증 1 - Validation
    검증 요구사항

    프로젝트 설정 V1

    검증 직접 처리 - 소개

    검증 직접 처리 - 개발
        모델에 검증 오류 결과가 포함되어야 한다! 이걸 담아주는 객체가 필요!

        model객체에 item객체를 담아주어서 자동으로 불러온다 딱히 rttr때문은 아님 rttr은 왜쓰고 무슨일하지 ???

        <div th:if="${errors?.containsKey('globalError')}">
        여기서 사용되는 errors? 는 errors가 null이면 무시되고 null이 아니면 실행
        즉 에러가 있어야 실행되는 문구이다.

        참고로 errors.containskey 에서 errors가 null 이면 NPE발생한다. 그래서 errors? 를 사용한다.

        여전히 문제점들!
        1. 뷰 템플릿 중복처리
        2. 다른 타입 입력 오류 처리 x, 이러한 오류는 컨트롤러에 들어오기 전에 터져버린다.
        3. 문자처리 불가로 바인딩 불가해서 고객이 입력한 문자가 사라지고, 고객은 어떤내용을 입력해서 오류가 발생했는지 이해하기 어렵다.
        4. 고객이 입력한 값 어딘가에 별도로 관리 필요

    프로젝트 준비 V2

    BindingResult1

        바인딩된 결과 뭐가바인딩? 앞에 매개변수가 바인딩된 결과가 담긴다.

        BindingResult는 항상 바인딩된 객체 바로 뒤에 위치해야 한다.

        스프링의 BindingResult를 활용하여 검증오류를 표현하는 기능을 제공
        #fields로 접근 가능
        th:error: 해달 필드에 오류가 있는 경우 출력 th:if의 편의버전
        th:errorclass: th:field에서 지정한 필드에 오류가 있으면 class정보를 추가한다.

    BindingResult2
        ★스프링이 제공하는 검증 오류를 보관하는 객체!!!
        BindingResult가 없으면 에러페이지로 넘어가버리고(컨트롤러 호출이 안된다), 있으면 컨트롤러가 호출이 된다.
        오류 결과를 가진채로 호출이 되는것

        BindingResult에 검증 오류를 적용하는 3가지 방법
        1. 타입오류 등으로 바인딩 실패하는 경우 FieldError 생성해서 BindingResult에 담아준다.
        2. 개발자가 직접 넣어줄 수 있다.
        3. Validator 사용

        두가지오류로 구분가능
        1. 바인딩 자체가 실패
        2. 비즈니스로직과 관련된 검증 오류

        Errors 인터페이스를 상속받은 BindingResult
        실제로 넘어오는 구현체는 BeanPropertyBindingResult인데 두개의 인터페이스를 모두 구현하였으므로 BindingResult대신에 errors를 써도 되지만 기능이 부족

        그런데 입력해놓은값이 잘못되어서 redirect가 됬을때 입력해놓은값, 데이터가 유지가 안된다.
        유지하려면은???
        FieldError와 ObjectError를 사용하면 된다.

    FieldError, ObjectError
        사용자 입력 오류 메시지가 화면에 남도록하자!
        FieldError와 ObjectError의 관계는 ???

        th:field="*{price}" 는 오류가있으면 fieldError 에서 값을 가져온다. 오류가 없으면 모델 객체에 있는 값을 사용한다.

    오류 코드와 메시지 처리 1
        오류 메시지를 일관성 있게 관리해보자.

        rejectedValue : 바인딩 실패한 값(사용자가 입력한 값, 거절된 값)

        errorCode와 arguments를 활용해서 오류메시지를 구분한다.

        properties 파일을 만들어서 오류를 코드화!

        메시지 소스를 자동으로 찾아서 조회한다. key, value로 불러온다. 그러니까 당연히 국제화도 가능!

    오류 코드와 메시지 처리 2


