검증 1 - Validation
    검증 요구사항

    프로젝트 설정 V1

    검증 직접 처리 - 소개

    검증 직접 처리 - 개발
        모델에 검증 오류 결과가 포함되어야 한다! 이걸 담아주는 객체가 필요!

        model객체에 item객체를 담아주어서 자동으로 불러온다 딱히 rttr때문은 아님 rttr은 왜쓰고 무슨일하지 ???

        <div th:if="${errors?.containsKey('globalError')}">
        여기서 사용되는 errors? 는 errors가 null이면 무시되고 null이 아니면 실행
        즉 에러가 있어야 실행되는 문구이다.

        참고로 errors.containskey 에서 errors가 null 이면 NPE발생한다. 그래서 errors? 를 사용한다.

        여전히 문제점들!
        1. 뷰 템플릿 중복처리
        2. 다른 타입 입력 오류 처리 x, 이러한 오류는 컨트롤러에 들어오기 전에 터져버린다.
        3. 문자처리 불가로 바인딩 불가해서 고객이 입력한 문자가 사라지고, 고객은 어떤내용을 입력해서 오류가 발생했는지 이해하기 어렵다.
        4. 고객이 입력한 값 어딘가에 별도로 관리 필요

    프로젝트 준비 V2

    BindingResult1

        바인딩된 결과 뭐가바인딩? 앞에 매개변수가 바인딩된 결과가 담긴다.

        BindingResult는 항상 바인딩된 객체 바로 뒤에 위치해야 한다.

        스프링의 BindingResult를 활용하여 검증오류를 표현하는 기능을 제공
        #fields로 접근 가능
        th:error: 해달 필드에 오류가 있는 경우 출력 th:if의 편의버전
        th:errorclass: th:field에서 지정한 필드에 오류가 있으면 class정보를 추가한다.

    BindingResult2
        ★스프링이 제공하는 검증 오류를 보관하는 객체!!!
        BindingResult가 없으면 에러페이지로 넘어가버리고(컨트롤러 호출이 안된다), 있으면 컨트롤러가 호출이 된다.
        오류 결과를 가진채로 호출이 되는것

        BindingResult에 검증 오류를 적용하는 3가지 방법
        1. 타입오류 등으로 바인딩 실패하는 경우 FieldError 생성해서 BindingResult에 담아준다.
        2. 개발자가 직접 넣어줄 수 있다.
        3. Validator 사용

        두가지오류로 구분가능
        1. 바인딩 자체가 실패
        2. 비즈니스로직과 관련된 검증 오류

        Errors 인터페이스를 상속받은 BindingResult
        실제로 넘어오는 구현체는 BeanPropertyBindingResult인데 두개의 인터페이스를 모두 구현하였으므로 BindingResult대신에 errors를 써도 되지만 기능이 부족

        그런데 입력해놓은값이 잘못되어서 redirect가 됬을때 입력해놓은값, 데이터가 유지가 안된다.
        유지하려면은???
        FieldError와 ObjectError를 사용하면 된다.

    FieldError, ObjectError
        사용자 입력 오류 메시지가 화면에 남도록하자!
        FieldError와 ObjectError의 관계는 ???

        th:field="*{price}" 는 오류가있으면 fieldError 에서 값을 가져온다. 오류가 없으면 모델 객체에 있는 값을 사용한다.

    오류 코드와 메시지 처리 1
        오류 메시지를 일관성 있게 관리해보자.

        rejectedValue : 바인딩 실패한 값(사용자가 입력한 값, 거절된 값)

        errorCode와 arguments를 활용해서 오류메시지를 구분한다.

        properties 파일을 만들어서 오류를 코드화!

        메시지 소스를 자동으로 찾아서 조회한다. key, value로 불러온다. 그러니까 당연히 국제화도 가능!

    오류 코드와 메시지 처리 2
        BindingResult는 검증해야할 객체 바로 뒤에 위치한다!(매개변수에서) 즉, 본인이 검증해야할 객체를 이미 알고 있다.

        rejectValue(), reject()를 사용하면 FieldError, ObjectError를  직접 생성하지 않고 더 깔끔하게 검증 오류를 다룰 수 있다.

        errorCode에 그냥 첫번째 문자만 넣어주면 된다. 그냥 properties에 부합하는것 가져오는 것, 그런데 앞글자는 중복되면 어떡함???

        에러 코드를 과연 어떤식으로 조합해서 만들어내는거야???

        사실 rejectValue에서 v3에서생성했던 fieldError를 대신 생성해준다.

    오류 코드와 메시지 처리 3
        오류 코드는 범용성과 관련이 많다.
        좋은 방법은 범용성으로 사용하다가 세밀하게 작성해야 하는 경우에는 세밀한 내용이 적용되도록 메시지에 단계를 두는것

        오류메시지에 객체명과 필드명을 조합한 세밀한 코드가 있으면 높은 우선순위가 작용되어서 먼저 사용된다.

    오류 코드와 메시지 처리 4
        DefaultMessageCodesResolver의 기본 메시지 생성 규칙

        객체오류
        필드오류

    오류 코드와 메시지 처리 5
        구체적인것을 만들고 약간 추상적인것을 만들어서 공통전략을 도입한다.
        모든 오류 코드에 대해서 메시지를 만들 수 있지만 그건 관리하기 너무 힘들다.

        application 코드의 변경 없이 properties만 변경해도 된다는 점이 굉장한 이점!!

        개발의 효율성 up!

    오류 코드와 메시지 처리 6
        1. 개발자가 직접 설정한 오류코드
        2. 스프링이 직접 검증 오류에 추가한 오류코드

        typeMismatch는 스프링이 직접 오류코드추가하면서 넣어준것 bindingresult에

        우리가 properties로 설정해서 원하는 코멘트 출력가능하다.

        메시지 코드 생성 전략!!! Bean Validation을 학습하면 진가를 더 확인할 수 있다.

    Validator 분리 1
        컨트롤러가 너무 많은일을하면 별도의 클래스로 분리하는것도 좋다.

        코드가 복잡해지면 이렇게 검증기를 만드는것 좋다.

        그냥 Validator를 상속받지 않고서도 검증기를 만드는것은 가능하다 그런데 왜 굳이 구현했을까??? 스프링에서 뭔가 해주는게 있다!(Bean Validation과 관련)

    Validator 분리 2
        @InitBinder는 해당 컨트롤러에만 적용 글로벌설정은 따로

        검증 메소드를 사용하지 않고 애너테이션으로 사용가능하게하는것이다.

        @Validated : 검증기를 실행하라!

        어떤 검증기를 실행해??? 검증기가 많을 수 도 있다. 그래서 구현하면서 supports를 구현한것이다.

        글로벌 설정은  실행 application에 넣어주면 모든 컨트롤러에서 사용가능 물론 그때도 supports먼저

        @Validate는 스프링제공, @Valid는 자바제공
        스프링으로가자

    정리
        클라이언트검증과 서버검증을 섞어서 해야한다!

        어떤 비즈니스 로직은 성공과 실패 등등 모두 고려해야하는 것 당연히 필수

        검증에 실패하면 오류 결과를 폼으로 전달해 주어야 한다.

        핵심은 구체적인것에서 덜 구체적인것으로

